# Architecture Research

**Domain:** PDF Analytics Dashboard (React SPA)
**Researched:** 2026-02-18
**Confidence:** HIGH (FSD official docs + TanStack Router docs + multiple verified sources)

---

## Standard Architecture: Feature Sliced Design (FSD)

### System Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│  APP LAYER — Bootstraps everything; no slice isolation               │
│  app/providers.tsx   app/router.tsx   app/styles.ts                  │
│  routeTree.gen.ts (auto-generated by TanStack Router Vite plugin)    │
├─────────────────────────────────────────────────────────────────────┤
│  PAGES LAYER — Thin assemblers; one slice per route                  │
│  ┌──────────────────┐   ┌──────────────────────────────────────┐    │
│  │ pages/reports    │   │ pages/report                         │    │
│  │ (list + upload)  │   │ (split layout: viewer + widget panel) │    │
│  └──────────────────┘   └──────────────────────────────────────┘    │
├─────────────────────────────────────────────────────────────────────┤
│  WIDGETS LAYER — Large, self-contained UI blocks                     │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────┐ ┌──────────────┐   │
│  │ pdf-viewer   │ │ widget-panel │ │ report-  │ │ upload-modal │   │
│  │              │ │              │ │ list     │ │              │   │
│  └──────────────┘ └──────────────┘ └──────────┘ └──────────────┘   │
├─────────────────────────────────────────────────────────────────────┤
│  FEATURES LAYER — User-facing interactions                           │
│  ┌───────────────┐ ┌─────────────┐ ┌─────────────┐ ┌───────────┐   │
│  │ upload-report │ │ filter-     │ │ zoom-pdf    │ │ auth-     │   │
│  │               │ │ reports     │ │             │ │ session   │   │
│  └───────────────┘ └─────────────┘ └─────────────┘ └───────────┘   │
├─────────────────────────────────────────────────────────────────────┤
│  ENTITIES LAYER — Business domain objects                            │
│  ┌──────────────┐  ┌─────────────────┐  ┌──────────────────────┐   │
│  │ report       │  │ user            │  │ widget-tab           │   │
│  │ (core model) │  │ (auth/session)  │  │ (tab state model)    │   │
│  └──────────────┘  └─────────────────┘  └──────────────────────┘   │
├─────────────────────────────────────────────────────────────────────┤
│  SHARED LAYER — Project-agnostic, no business knowledge             │
│  ┌───────────┐ ┌────────────┐ ┌─────────────┐ ┌────────────────┐   │
│  │ shared/ui │ │ shared/api │ │ shared/lib  │ │ shared/config  │   │
│  │ (design   │ │ (axios     │ │ (pdfjs,     │ │ (env, routes)  │   │
│  │  system)  │ │  client)   │ │  cn, utils) │ │                │   │
│  └───────────┘ └────────────┘ └─────────────┘ └────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### Import Rule (Enforced)

Each layer can ONLY import from layers strictly below it. Same-layer imports are forbidden except via the `@x` cross-import notation for entities.

```
app       → pages, widgets, features, entities, shared
pages     → widgets, features, entities, shared
widgets   → features, entities, shared
features  → entities, shared
entities  → shared (+ other entities via @x only)
shared    → nothing (no business imports)
```

---

## Full FSD Directory Tree for This Project

```
src/
├── app/
│   ├── providers.tsx          # React root: QueryClientProvider, RouterProvider
│   ├── router.tsx             # createRouter(), router instance
│   ├── styles/
│   │   └── globals.css        # Tailwind base + global CSS vars
│   └── index.tsx              # ReactDOM.createRoot entry (imports app/providers)
│
├── pages/
│   ├── reports/               # Route: /reports (report list + upload)
│   │   ├── ui/
│   │   │   └── ReportsPage.tsx      # Assembles: ReportList widget + UploadModal widget
│   │   └── index.ts                 # export { ReportsPage }
│   │
│   └── report/                # Route: /report/:reportId (split layout)
│       ├── ui/
│       │   ├── ReportPage.tsx       # Split layout: left=PdfViewer, right=WidgetPanel
│       │   └── ReportPageLayout.tsx # CSS grid: two-column split
│       ├── route.tsx                # createFileRoute('/report/$reportId')
│       └── index.ts                 # export { ReportPage }
│
├── widgets/
│   ├── pdf-viewer/            # Right panel: PDF display + controls
│   │   ├── ui/
│   │   │   ├── PdfViewer.tsx        # Virtualized page renderer, minimap, zoom
│   │   │   └── PdfMinimap.tsx       # Page thumbnail strip
│   │   ├── model/
│   │   │   └── pdf-viewer.store.ts  # Zustand: currentPage, zoom, highlights
│   │   └── index.ts                 # export { PdfViewer }
│   │
│   ├── widget-panel/          # Left panel: tabbed analytics (charts/tables/stats/text)
│   │   ├── ui/
│   │   │   ├── WidgetPanel.tsx      # Tab nav + outlet for sub-widgets
│   │   │   ├── ChartsTab.tsx        # Charts sub-widget view
│   │   │   ├── TablesTab.tsx        # Tables sub-widget view
│   │   │   ├── StatsTab.tsx         # Stats sub-widget view
│   │   │   └── TextTab.tsx          # Text highlights sub-widget view
│   │   ├── model/
│   │   │   └── active-tab.store.ts  # Zustand: activeTab, URL param sync
│   │   └── index.ts                 # export { WidgetPanel }
│   │
│   ├── report-list/           # Reports index page list
│   │   ├── ui/
│   │   │   └── ReportList.tsx       # List of report cards
│   │   └── index.ts                 # export { ReportList }
│   │
│   └── upload-modal/          # PDF upload dialog
│       ├── ui/
│       │   └── UploadModal.tsx      # Drag-and-drop upload form
│       └── index.ts                 # export { UploadModal }
│
├── features/
│   ├── upload-report/         # User action: upload PDF
│   │   ├── ui/
│   │   │   └── UploadForm.tsx       # Form component (used by UploadModal widget)
│   │   ├── model/
│   │   │   └── upload.store.ts      # Zustand: upload progress, error
│   │   ├── api/
│   │   │   └── uploadReport.ts      # POST /api/reports (mocked in v1)
│   │   └── index.ts                 # export { UploadForm }
│   │
│   ├── filter-reports/        # User action: filter/search reports
│   │   ├── ui/
│   │   │   └── ReportFilters.tsx    # Search input + filter controls
│   │   ├── model/
│   │   │   └── filters.store.ts     # Zustand: query, date range, sort
│   │   └── index.ts                 # export { ReportFilters }
│   │
│   ├── zoom-pdf/              # User action: zoom PDF viewer
│   │   ├── ui/
│   │   │   └── ZoomControls.tsx     # +/- zoom buttons
│   │   ├── model/
│   │   │   └── zoom.store.ts        # Zustand: zoomLevel (1.0 default)
│   │   └── index.ts                 # export { ZoomControls }
│   │
│   └── auth-session/          # User action: login/logout
│       ├── ui/
│       │   └── LoginForm.tsx        # Login form (small team auth)
│       ├── model/
│       │   └── session.store.ts     # Zustand: currentUser, isAuthenticated
│       ├── api/
│       │   └── auth.ts              # POST /api/auth (mocked in v1)
│       └── index.ts                 # export { LoginForm }
│
├── entities/
│   ├── report/                # Business object: Report
│   │   ├── ui/
│   │   │   └── ReportCard.tsx       # Report card UI (used by report-list widget)
│   │   ├── model/
│   │   │   ├── report.types.ts      # Report, ReportStatus, ReportMetadata types
│   │   │   ├── report.schema.ts     # Zod validation schema
│   │   │   └── report.store.ts      # Zustand: reports[], selectedReport
│   │   ├── api/
│   │   │   └── reportsApi.ts        # GET /api/reports, GET /api/reports/:id
│   │   └── index.ts                 # export { ReportCard, useReportStore, reportSchema }
│   │
│   ├── user/                  # Business object: User
│   │   ├── model/
│   │   │   ├── user.types.ts        # User, Role types
│   │   │   └── user.store.ts        # Zustand: current user state
│   │   └── index.ts                 # export { useUserStore }
│   │
│   └── widget-tab/            # Business object: WidgetTab (charts/tables/stats/text)
│       ├── model/
│       │   ├── tab.types.ts         # TabId union type, TabConfig
│       │   └── tab.constants.ts     # TABS array with ids/labels/paths
│       └── index.ts                 # export { TabId, TABS }
│
└── shared/
    ├── ui/                    # Design system components (no business logic)
    │   ├── Button.tsx
    │   ├── Modal.tsx
    │   ├── Tabs.tsx
    │   ├── Spinner.tsx
    │   └── index.ts
    │
    ├── api/                   # HTTP client setup
    │   ├── client.ts          # axios instance, base URL, interceptors
    │   └── index.ts
    │
    ├── lib/                   # Third-party wrappers (no business logic)
    │   ├── pdfjs/
    │   │   ├── setup.ts       # pdfjsLib.GlobalWorkerOptions.workerSrc = ...
    │   │   ├── usePdfDocument.ts  # Hook: loads PDF, returns PDFDocumentProxy
    │   │   └── index.ts       # export { usePdfDocument, initPdfWorker }
    │   ├── cn.ts              # clsx + tailwind-merge utility
    │   └── index.ts
    │
    ├── config/
    │   ├── env.ts             # import.meta.env typed constants
    │   ├── routes.ts          # Route path constants (ROUTES.report(':id'))
    │   └── index.ts
    │
    └── types/
        └── global.d.ts        # Module augmentations, env types
```

---

## Component Boundaries

| Component | Responsibility | Can Import From | Cannot Import From |
|-----------|---------------|-----------------|-------------------|
| `app/` | Bootstrap: router, providers, global store init | Everything | Nothing is above app |
| `pages/report` | Assemble split-layout: PdfViewer + WidgetPanel | widgets, features, entities, shared | Other pages |
| `pages/reports` | Assemble list view: ReportList + UploadModal | widgets, features, entities, shared | Other pages |
| `widgets/pdf-viewer` | Render PDF, manage local view state | features, entities, shared | Pages, other widgets |
| `widgets/widget-panel` | Tab routing + analytics views | features, entities, shared | Pages, other widgets |
| `widgets/report-list` | Display list of reports | features, entities, shared | Pages, other widgets |
| `features/upload-report` | Handle PDF upload action | entities, shared | Widgets, pages |
| `features/filter-reports` | Manage filter state | entities, shared | Widgets, pages |
| `entities/report` | Report data model + API | shared | Features, widgets, pages |
| `shared/lib/pdfjs` | pdf.js wrapper, no business knowledge | Nothing | Everything above |

---

## Architectural Patterns

### Pattern 1: Public API via index.ts

**What:** Every slice exposes one and only one public API file (`index.ts`). External code imports only from this file, never from internal paths.

**When to use:** Always. Every slice in every layer.

**Example:**

```typescript
// entities/report/index.ts — Public API
export { ReportCard } from "./ui/ReportCard";
export { useReportStore } from "./model/report.store";
export type { Report, ReportStatus } from "./model/report.types";
export { reportsApi } from "./api/reportsApi";

// CORRECT usage from a widget:
import { ReportCard, useReportStore } from "@/entities/report";

// WRONG — bypasses public API, breaks encapsulation:
import { ReportCard } from "@/entities/report/ui/ReportCard"; // ❌
```

**Enforcement:** Configure TypeScript path aliases + eslint-plugin-import or @feature-sliced/eslint-plugin to flag internal imports.

---

### Pattern 2: Cross-Widget Communication via Shared Zustand Store in Entities

**What:** When two widgets on the same page need to sync (e.g., clicking a highlight in widget-panel jumps to that page in pdf-viewer), they cannot import each other (same-layer rule). Instead, both widgets read from and write to a shared store defined in `entities/report/model`.

**When to use:** Any time two sibling widgets need to coordinate.

**Example:**

```typescript
// entities/report/model/report-view.store.ts
// "View state for the currently open report — shared between pdf-viewer and widget-panel"
import { create } from "zustand";

interface ReportViewState {
  activePage: number;
  highlightedWidgetId: string | null;
  setActivePage: (page: number) => void;
  setHighlightedWidget: (id: string | null) => void;
}

export const useReportViewStore = create<ReportViewState>((set) => ({
  activePage: 1,
  highlightedWidgetId: null,
  setActivePage: (page) => set({ activePage: page }),
  setHighlightedWidget: (id) => set({ highlightedWidgetId: id }),
}));
```

```typescript
// widgets/pdf-viewer/ui/PdfViewer.tsx
// Reads activePage from entities store — reacts to widget panel changes
import { useReportViewStore } from "@/entities/report";

export const PdfViewer = () => {
  const { activePage, setActivePage } = useReportViewStore();
  // pdf-viewer scrolls to activePage when it changes
  // sets activePage when user scrolls manually
};
```

```typescript
// widgets/widget-panel/ui/ChartsTab.tsx
// Writes to entities store — pdf-viewer reacts automatically
import { useReportViewStore } from "@/entities/report";

export const ChartsTab = () => {
  const { setActivePage, setHighlightedWidget } = useReportViewStore();
  // When user clicks a chart annotation, call setActivePage(n) + setHighlightedWidget(id)
};
```

**Why this is correct FSD:** Both widgets import from `entities/report` (a lower layer). No same-layer imports. The shared state is a domain concept (the "view state of the current report") so it belongs in `entities/report/model`.

---

### Pattern 3: TanStack Router in the App Layer + Pages Layer Route Files

**What:** The router instance lives in `app/router.tsx`. TanStack Router's Vite plugin is configured to read routes from `src/pages/` instead of `src/routes/`. Each page slice contains its own route definition file.

**When to use:** Always with TanStack Router + FSD.

**Configuration:**

```typescript
// vite.config.ts
import { TanStackRouterVite } from "@tanstack/router-plugin/vite";

export default defineConfig({
  plugins: [
    TanStackRouterVite({
      routesDirectory: "./src/pages",         // Points to FSD pages layer
      generatedRouteTree: "./src/routeTree.gen.ts",
    }),
    react(),
  ],
});
```

```typescript
// src/pages/report/route.tsx
// Route definition lives in the pages slice
import { createFileRoute } from "@tanstack/react-router";
import { ReportPage } from "./ui/ReportPage";

export const Route = createFileRoute("/report/$reportId")({
  component: ReportPage,
  loader: ({ params }) => fetchReport(params.reportId), // calls entities/report/api
});
```

```typescript
// src/app/router.tsx
// Router instance assembled from generated route tree (auto-generated by Vite plugin)
import { createRouter } from "@tanstack/react-router";
import { routeTree } from "../routeTree.gen";

export const router = createRouter({ routeTree });
```

```typescript
// src/app/providers.tsx
// App bootstrap: all providers wrapped here
import { RouterProvider } from "@tanstack/react-router";
import { QueryClientProvider } from "@tanstack/react-query";
import { router } from "./router";
import { queryClient } from "./query-client";

export const AppProviders = () => (
  <QueryClientProvider client={queryClient}>
    <RouterProvider router={router} />
  </QueryClientProvider>
);
```

---

### Pattern 4: Widget Panel Nested Sub-Routes (URL-Based Tab Sync)

**What:** The widget panel's tabs (charts/tables/stats/text) are URL-driven: navigating to `/report/123/charts` activates the Charts tab. This is implemented as nested routes within the `pages/report` slice. The widgets layer WidgetPanel component renders an `<Outlet>` for the active tab.

**Why URL-based:** Ensures deep-linkability, browser back/forward support, and no hidden state for tab position.

**Route structure:**

```
/report/$reportId              → ReportPage (split layout)
/report/$reportId/             → redirect to /charts
/report/$reportId/charts       → ChartsTab (within WidgetPanel)
/report/$reportId/tables       → TablesTab
/report/$reportId/stats        → StatsTab
/report/$reportId/text         → TextTab
```

```typescript
// pages/report/ui/ReportPage.tsx
import { PdfViewer } from "@/widgets/pdf-viewer";
import { WidgetPanel } from "@/widgets/widget-panel";

export const ReportPage = () => (
  <div className="grid grid-cols-[1fr_1fr] h-screen">
    <WidgetPanel />   {/* Left — renders <Outlet> for active tab */}
    <PdfViewer />     {/* Right — synced via entities/report store */}
  </div>
);
```

```typescript
// widgets/widget-panel/ui/WidgetPanel.tsx
import { Outlet, Link } from "@tanstack/react-router";
import { TABS } from "@/entities/widget-tab";

export const WidgetPanel = () => (
  <div>
    <nav>
      {TABS.map(tab => (
        <Link key={tab.id} to={tab.path}>{tab.label}</Link>
      ))}
    </nav>
    <Outlet />   {/* Tab content rendered here */}
  </div>
);
```

---

### Pattern 5: pdf.js Wrapper in shared/lib

**What:** `pdfjs-dist` is a third-party library with no business knowledge. Its initialization (worker setup) and core usage hook live in `shared/lib/pdfjs`. The widget `pdf-viewer` imports from `shared/lib/pdfjs` to render PDFs.

**Critical worker setup detail:** The `workerSrc` must be set in the same module execution context as the PDF rendering components. Configure it in `shared/lib/pdfjs/setup.ts` and import that in `app/providers.tsx` (the bootstrap module) to guarantee it runs before any PDF rendering.

**Example:**

```typescript
// shared/lib/pdfjs/setup.ts
import * as pdfjsLib from "pdfjs-dist";
pdfjsLib.GlobalWorkerOptions.workerSrc =
  new URL("pdfjs-dist/build/pdf.worker.min.mjs", import.meta.url).href;
export { pdfjsLib };
```

```typescript
// shared/lib/pdfjs/usePdfDocument.ts
import { useEffect, useState } from "react";
import { pdfjsLib } from "./setup";
import type { PDFDocumentProxy } from "pdfjs-dist";

export const usePdfDocument = (url: string) => {
  const [doc, setDoc] = useState<PDFDocumentProxy | null>(null);
  useEffect(() => {
    const task = pdfjsLib.getDocument(url);
    task.promise.then(setDoc);
    return () => task.destroy();
  }, [url]);
  return doc;
};
```

```typescript
// shared/lib/pdfjs/index.ts
export { pdfjsLib } from "./setup";
export { usePdfDocument } from "./usePdfDocument";
```

---

## Data Flow

### Report List Page Flow

```
User lands on /reports
    ↓
pages/reports/ui/ReportsPage.tsx
    ↓ renders
widgets/report-list  +  widgets/upload-modal
    ↓ (report-list)
features/filter-reports (ReportFilters: query, sort)
    ↓ filtered params passed down
entities/report/api/reportsApi.ts  ← TanStack Query (useQuery)
    ↓
shared/api/client.ts (axios, mocked in v1)
    ↓ response
entities/report/model/report.store.ts (Zustand: reports[])
    ↓ data
widgets/report-list/ui/ReportList.tsx → entities/report/ui/ReportCard.tsx
```

### Report Page Flow (Split Layout)

```
User navigates to /report/:reportId
    ↓
pages/report/route.tsx (TanStack Router loader calls entities/report/api)
    ↓ loader data
pages/report/ui/ReportPage.tsx (assembles split layout)
    │
    ├── LEFT: widgets/widget-panel
    │         reads: entities/widget-tab (TABS config)
    │         reads/writes: entities/report (useReportViewStore — shared sync state)
    │         renders: <Outlet> → ChartsTab / TablesTab / StatsTab / TextTab
    │         on click annotation → setActivePage(n) → triggers pdf-viewer sync
    │
    └── RIGHT: widgets/pdf-viewer
              reads: entities/report (useReportViewStore.activePage)
              reads: features/zoom-pdf (zoom level)
              reads: shared/lib/pdfjs (usePdfDocument hook)
              renders: virtualized pages, minimap
              on scroll → setActivePage(n) → triggers widget-panel sync
```

### Cross-Widget Sync Data Flow

```
User clicks chart annotation (page 5 reference)
    ↓
widgets/widget-panel writes to entities/report/model (setActivePage(5))
    ↓ Zustand subscription
widgets/pdf-viewer reads activePage = 5
    ↓
pdf-viewer scrolls to page 5
    ↓ (simultaneously)
pdf-viewer sets highlightPage CSS on page 5
```

---

## Build Order (Which FSD Layers to Build First)

Building bottom-up respects the import dependency direction and prevents blocking:

**Phase 1 — Shared Foundation**
- `shared/ui` (Button, Modal, Tabs, Spinner, layout primitives)
- `shared/api` (axios client, mock interceptor)
- `shared/lib/pdfjs` (worker setup, usePdfDocument hook)
- `shared/config` (route constants, env)

**Phase 2 — Entities (Business Models)**
- `entities/report` (types, Zod schema, mock API, Zustand store including `useReportViewStore`)
- `entities/user` (types, session store)
- `entities/widget-tab` (TabId type, TABS constant)

**Phase 3 — Features (User Actions)**
- `features/auth-session` (login form + session store, mocked)
- `features/upload-report` (upload form + mock API)
- `features/filter-reports` (filter store)
- `features/zoom-pdf` (zoom controls + zoom store)

**Phase 4 — Widgets (UI Blocks)**
- `widgets/report-list` (depends on entities/report)
- `widgets/upload-modal` (depends on features/upload-report)
- `widgets/pdf-viewer` (depends on shared/lib/pdfjs, entities/report, features/zoom-pdf)
- `widgets/widget-panel` (depends on entities/widget-tab, entities/report)

**Phase 5 — Pages + App (Route Assembly)**
- `pages/reports` (assembles report-list + upload-modal)
- `pages/report` (assembles pdf-viewer + widget-panel, defines nested routes)
- `app/` (router, providers, bootstrap)

**Rationale:** Each phase only depends on already-built lower phases. This allows parallel development of features/entities once shared is done. Mock API at `shared/api` level means UI can be built without a real backend.

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Widgets Importing Each Other

**What people do:** `widgets/pdf-viewer` imports `widgets/widget-panel` to call a sync function directly.

**Why it's wrong:** Violates FSD same-layer isolation. Creates circular dependency risk, breaks encapsulation, makes widgets non-reusable.

**Do this instead:** Both widgets read from a shared Zustand store in `entities/report/model` (a lower layer). Neither imports the other.

---

### Anti-Pattern 2: Business Logic in shared/

**What people do:** Putting `useReportViewStore` or report-specific logic into `shared/lib` or `shared/model`.

**Why it's wrong:** `shared/` must be business-agnostic. Anything in `shared/` gets imported by everything — polluting it with domain concepts defeats the purpose.

**Do this instead:** Domain-specific shared state (like cross-widget sync state for the current report) goes in `entities/report/model`. Pure utilities (clsx, axios, pdfjs setup) go in `shared/`.

---

### Anti-Pattern 3: Pages Containing Business Logic

**What people do:** Putting query calls, store logic, or large UI directly in `pages/report/ui/ReportPage.tsx`.

**Why it's wrong:** Pages become monoliths that can't be tested, can't be composed, and accumulate scope over time.

**Do this instead:** Pages are thin assemblers — they render widgets, pass route params down, and let widgets/features/entities own all logic. Keep page components under 50 lines.

---

### Anti-Pattern 4: Skipping index.ts Public APIs

**What people do:** Importing directly from internal slice paths: `import { Report } from "@/entities/report/model/report.types"`.

**Why it's wrong:** Internal structure changes break consumers. Impossible to audit what's public. Tooling (eslint-plugin) can't enforce boundaries.

**Do this instead:** Every slice has an `index.ts` that explicitly re-exports its public surface. Configure TypeScript aliases + eslint to make direct internal imports impossible.

---

### Anti-Pattern 5: Putting the pdf.js Worker Config Anywhere But setup.ts + app Bootstrap

**What people do:** Configuring `pdfjsLib.GlobalWorkerOptions.workerSrc` inside a component or inside a lazy-loaded module.

**Why it's wrong:** Module execution order is non-deterministic with code splitting and lazy imports. The worker may not be configured before first PDF render.

**Do this instead:** Configure worker in `shared/lib/pdfjs/setup.ts` and import that module in `app/providers.tsx` (synchronously, before any routing).

---

## Integration Points

### Internal Boundaries

| Boundary | Communication Pattern | Notes |
|---|---|---|
| widget-panel ↔ pdf-viewer | Shared Zustand store in `entities/report/model` | No direct imports between widgets |
| pages/report ↔ widgets | React component composition (pages render widgets) | Normal downward FSD dependency |
| features/upload-report ↔ widgets/upload-modal | Feature renders UI inside widget container | Widget imports feature component |
| TanStack Router ↔ FSD pages layer | `routesDirectory: "./src/pages"` in Vite config | Route files live in page slices |
| TanStack Router ↔ app layer | `router.tsx` in `app/` consumes `routeTree.gen.ts` | Generated file auto-updated by Vite plugin |
| widget-panel tabs ↔ URL | TanStack Router `<Outlet>` + `<Link>` with path constants from `shared/config/routes.ts` | Tab state = URL state |

### External Services

| Service | Integration Pattern | Notes |
|---|---|---|
| Mock API (v1) | axios interceptors in `shared/api/client.ts` | Replace with real endpoints in v2 |
| pdfjs-dist | Wrapper in `shared/lib/pdfjs` | Worker must be initialized at app bootstrap |
| TanStack Query | `QueryClientProvider` in `app/providers.tsx` | Queries defined in `entities/*/api/` |

---

## Scaling Considerations

| Scale | Architecture Adjustments |
|---|---|
| v1 (mocked scaffold, 1-5 users) | All data mocked in `shared/api/client.ts` interceptors; no real backend needed |
| v2 (10-100 users) | Swap mock interceptors for real API; add error boundaries at page level; split code with lazy() on page routes |
| v3 (100-1000 users) | Add authentication guards as TanStack Router `beforeLoad` in app layer; add optimistic UI in entity stores; virtualize long report lists |
| Scale+ | Extract `shared/ui` to a design system package; split Zustand stores with `zustand/middleware/devtools`; add Steiger CI linting |

### Scaling Priorities

1. **First bottleneck:** Large PDF files — virtual page rendering (only render visible pages via IntersectionObserver) must be in `widgets/pdf-viewer` from day one. Do not defer virtualization.
2. **Second bottleneck:** Report list with 1000+ items — paginated/infinite scroll queries in `entities/report/api`; the entity layer handles this without touching widgets or pages.

---

## Sources

- Feature-Sliced Design official layers documentation: https://feature-sliced.design/docs/reference/layers (HIGH confidence)
- FSD public API pattern: https://feature-sliced.design/docs/reference/public-api (HIGH confidence)
- FSD tutorial (Remix/file-based routing integration): https://feature-sliced.design/docs/get-started/tutorial (HIGH confidence)
- FSD page layout guide: https://feature-sliced.design/docs/guides/examples/page-layout (HIGH confidence)
- FSD slices and segments reference: https://feature-sliced.design/docs/reference/slices-segments (HIGH confidence)
- TanStack Router Vite plugin `routesDirectory` config: https://tanstack.com/router/v1/docs/framework/react/installation/with-vite (HIGH confidence, verified via WebSearch)
- Cross-slice communication and `@x` notation: https://feature-sliced.design/docs/reference/layers (HIGH confidence, standardized)
- Zustand store placement in FSD model segment: Verified via multiple sources (HIGH confidence)
- pdf.js worker setup ordering constraint: https://www.npmjs.com/package/pdfjs-dist + community sources (MEDIUM confidence — official npm page + ecosystem verification)
- Steiger FSD linter: https://github.com/feature-sliced/steiger (MEDIUM confidence — referenced in community sources, official FSD GitHub org)

---

*Architecture research for: PDF Analytics Dashboard (FSD)*
*Researched: 2026-02-18*
